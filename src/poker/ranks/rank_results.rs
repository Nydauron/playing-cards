use std::{
    collections::{BTreeMap, HashMap, HashSet},
    hash::Hash,
};

use itertools::Itertools;

use super::IntoRankStrengthIterator;

/// Contains information on which key has the strongest rank (i.e the winning hand)
///
/// The struct does not contain any `Rank` types, but rather contains the keys associated with the
/// rank. The underlying implementation uses hashsets to store the keys so the generic type `T`
/// must fulfill the traits `Hash`, `Eq`, and `Copy`.
///
/// The vectors returned by the iterator or `hand_number(&self)` is a list of hashsets of keys. The
/// list is sorted by strength of the key's rank with index 0 being of the strongest rank.
#[derive(Debug, Clone)]
pub struct RankResults<T: Hash + Eq + Copy> {
    hand_table: BTreeMap<usize, Vec<HashSet<T>>>,
}

impl<T: Hash + Eq + Copy> RankResults<T> {
    /// Generates a new `RankResults<T>`.
    ///
    /// This does not do any other post-computation. This is typically called within the
    /// `generate_winner_list()` functions.
    pub fn new(hand_table: BTreeMap<usize, Vec<HashSet<T>>>) -> Self {
        Self { hand_table }
    }

    /// Gets the specified hand number if it exists.
    ///
    /// Similar to indexing an vector, this will either return a list of hashsets of keys which are
    /// sorted by the strength of the key's rank, or None if the index does not exist.
    pub fn hand_number(&self, n: usize) -> Option<&Vec<HashSet<T>>> {
        self.hand_table.get(&n)
    }
}

impl<'a, T: Hash + Eq + Copy> IntoIterator for &'a RankResults<T> {
    type Item = (usize, Vec<HashSet<T>>);
    type IntoIter = std::collections::btree_map::IntoIter<usize, Vec<HashSet<T>>>;

    fn into_iter(self) -> Self::IntoIter {
        self.hand_table.clone().into_iter()
    }
}

/// Generates a vector of type T which can be used to direct who is the winner.
///
/// This function assumes all `Vec<Rank>` types were generated by `high_evaluator::evaluate_hand()`.
/// Giving another `Vec<Rank>` from a different evaluator can lead to undefined behavior.
///
/// A `RankResults<T>` type is returned. This can then be used to view individual hand and can be
/// iterated across.
pub fn generate_winner_list<T, U>(ranks: &HashMap<T, U>) -> RankResults<T>
where
    T: Eq + Hash + Copy,
    U: IntoRankStrengthIterator + Clone,
{
    let mut iters = ranks
        .iter()
        .map(|(k, v)| (k, v.clone().into_strength_iter()))
        .collect::<HashMap<_, _>>();

    let len = *match iters
        .values()
        .map(|iter| iter.len())
        .collect::<Vec<_>>()
        .as_slice()
    {
        [head, tail @ ..] => tail.iter().all(|len| len == head).then_some(head),
        [] => None,
    }
    .unwrap_or(&0);

    let transpose: Vec<HashMap<T, u32>> = (0..len)
        .map(|_| {
            iters
                .iter_mut()
                .map(|(&k, v)| (k, v.next().unwrap()))
                .filter(|(_, v)| v.is_some())
                .map(|(k, v)| (*k, v.unwrap()))
                .collect::<HashMap<T, u32>>()
        })
        .collect();

    let table: BTreeMap<usize, _> = transpose
        .iter()
        .enumerate()
        .map(|(i, ranks)| {
            let sorted_ranks_desc = ranks
                .iter()
                .sorted_by(|a, b| a.1.cmp(b.1))
                .rev()
                .collect::<Vec<_>>();

            if sorted_ranks_desc.is_empty() {
                return (i, vec![]);
            }

            let mut ranking_list = vec![HashSet::from([*sorted_ranks_desc[0].0])];
            let _: () = sorted_ranks_desc
                .windows(2)
                .flat_map(<&[(&T, &u32); 2]>::try_from)
                .map(|&[(_, prev_rank), (curr_id, curr_rank)]| {
                    if prev_rank == curr_rank {
                        ranking_list.last_mut().unwrap().insert(*curr_id);
                    } else {
                        ranking_list.push(HashSet::from([*curr_id]));
                    }
                })
                .collect();

            (i, ranking_list)
        })
        .collect();

    RankResults::new(table)
}

#[cfg(test)]
mod tests {
    use crate::poker::ranks::{
        BasicRank, HighRank, LowA5Rank, OmahaHiLoRank, RankStrengthIterator,
    };

    use super::*;

    #[test]
    fn get_simple_winner_list() {
        let ranks = HashMap::from([
            (
                1,
                OmahaHiLoRank {
                    hi_rank: HighRank(BasicRank {
                        strength: 4321,
                        hand_rank: 5,
                        sub_rank: 12,
                        description: Some("Some sick hand".to_string()),
                    }),
                    lo_rank: Some(LowA5Rank(BasicRank {
                        strength: 121,
                        hand_rank: 7,
                        sub_rank: 1,
                        description: Some("Some good low hand".to_string()),
                    })),
                },
            ),
            (
                2,
                OmahaHiLoRank {
                    hi_rank: HighRank(BasicRank {
                        strength: 2012,
                        hand_rank: 4,
                        sub_rank: 1232,
                        description: Some("Another sick hand".to_string()),
                    }),
                    lo_rank: None,
                },
            ),
        ]);

        let rank_results = generate_winner_list(&ranks);

        let expected_rank_results = BTreeMap::from([
            (0, vec![HashSet::from([1]), HashSet::from([2])]),
            (1, vec![HashSet::from([1])]),
        ]);
        for (winner_col, expected_winner_col) in rank_results
            .into_iter()
            .zip(expected_rank_results.into_iter())
        {
            assert_eq!(winner_col, expected_winner_col);
        }
    }

    #[derive(Debug, Clone, PartialEq, Eq)]
    struct DoubleBoardRank {
        pub top_board_rank: HighRank,
        pub bottom_board_rank: HighRank,
    }

    impl IntoRankStrengthIterator for DoubleBoardRank {
        fn into_strength_iter(self) -> RankStrengthIterator {
            RankStrengthIterator::from(vec![
                (*self.top_board_rank).strength,
                (*self.bottom_board_rank).strength,
            ])
        }
    }

    #[test]
    fn get_winner_list_custom_rank_type() {
        let ranks = HashMap::from([
            (
                1,
                DoubleBoardRank {
                    top_board_rank: HighRank(BasicRank {
                        strength: 2034,
                        hand_rank: 4,
                        sub_rank: 8,
                        description: Some("Decent high hand".to_string()),
                    }),
                    bottom_board_rank: HighRank(BasicRank {
                        strength: 7922,
                        hand_rank: 7,
                        sub_rank: 24,
                        description: Some("Nutted high hand".to_string()),
                    }),
                },
            ),
            (
                2,
                DoubleBoardRank {
                    top_board_rank: HighRank(BasicRank {
                        strength: 5000,
                        hand_rank: 6,
                        sub_rank: 54,
                        description: Some("The nuts on the top board".to_string()),
                    }),
                    bottom_board_rank: HighRank(BasicRank {
                        strength: 800,
                        hand_rank: 1,
                        sub_rank: 27,
                        description: Some("No pair hand".to_string()),
                    }),
                },
            ),
        ]);

        let rank_results = generate_winner_list(&ranks);

        let expected_rank_results = BTreeMap::from([
            (0, vec![HashSet::from([2]), HashSet::from([1])]),
            (1, vec![HashSet::from([1]), HashSet::from([2])]),
        ]);

        for (winner_col, expected_winner_col) in rank_results
            .into_iter()
            .zip(expected_rank_results.into_iter())
        {
            assert_eq!(winner_col, expected_winner_col);
        }
    }

    #[test]
    fn winner_list_same_rank() {
        let ranks = HashMap::from([
            (
                1,
                HighRank(BasicRank {
                    strength: 4321,
                    hand_rank: 5,
                    sub_rank: 12,
                    description: Some("Sick hand".to_string()),
                }),
            ),
            (
                2,
                HighRank(BasicRank {
                    strength: 4321,
                    hand_rank: 5,
                    sub_rank: 12,
                    description: Some("Sick hand".to_string()),
                }),
            ),
        ]);

        let rank_results = generate_winner_list(&ranks);

        let expected_rank_results = BTreeMap::from([(0, vec![HashSet::from([1, 2])])]);
        for (winner_col, expected_winner_col) in rank_results
            .into_iter()
            .zip(expected_rank_results.into_iter())
        {
            assert_eq!(winner_col, expected_winner_col);
        }
    }

    #[test]
    fn generate_winners_from_empty_input() {
        let ranks: HashMap<i32, HighRank> = HashMap::new();

        let rank_results = generate_winner_list(&ranks);

        let expected_rank_results: RankResults<i32> = RankResults::new(BTreeMap::new());

        for (winner_col, expected_winner_col) in rank_results
            .into_iter()
            .zip(expected_rank_results.into_iter())
        {
            assert_eq!(winner_col, expected_winner_col);
        }
    }
}
