use std::{cmp::Ordering, hash::Hash, collections::{HashSet, HashMap, BTreeMap}};

use itertools::Itertools;

use super::evaluator_result::IntoRankStrengthIterator;

/// A fundational struct to contain hand strength metadata.
///
/// The `BasicRank` struct is fairly trasparent allowing for easy access for evaluators to create
/// and modify values within the struct. The struct primarily stores information on hand strength,
/// even containing information on hand rank and sub rank if the user wants to utilize those
/// properites.
///
/// A provided description is also included to allow for the user to understand what the rank is in
/// English. Typically, the `description` field is going to be the the strength of the hand, but if
/// the evaluator fails for whatever reason, it will contain an error message instead.
///
/// Ranks can be compared with each other using the typical equality and inequality operations.
/// The evaluators that are provided in the `evaluator` module produce structs that rely on this
/// foundational struct.
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct BasicRank {
    /// The strength of the `Rank`.
    ///
    /// This field is what is used within the implematation of `Ord`
    /// and `Eq`.
    pub strength: u32,

    /// the hand rank of the associated rank.
    ///
    /// Two different ranks from two different evaluators might have the same `strength`, they may
    /// differ in `hand_rank`.
    pub hand_rank: u16,

    /// The sub rank of the associated rank.
    ///
    /// Typically `sub_rank` is used in tandem with `hand_rank`.
    pub sub_rank: u16,

    /// An optional description for the rank.
    ///
    /// All the provided evaluators in this library fill this field. Typically, value that is
    /// populated is a Enlgish version of the hand made (e.g. "Trip 5s", "Kings full of 9s"). If
    /// the evaluator fails to generate a valid description, the error string will be populated
    /// here.
    pub description: Option<String>,
}

impl Ord for BasicRank {
    fn cmp(&self, other: &Self) -> Ordering {
        self.strength.cmp(&other.strength)
    }
}

impl PartialOrd for BasicRank {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

/// Contains information on which key has the strongest rank (i.e the winning hand).
///
/// The struct does not contain any `Rank` types, but rather contains the keys associated with the
/// rank. The underlying implementation uses HashSets to store the keys so the generic type `T`
/// must fulfill the traits `Hash`, `Eq`, and `Copy`.
///
/// The vectors returned by the iterator or `hand_number(&self)` is a list of hashsets of keys. The
/// list is sorted by strength of the key's rank with index 0 being of the strongest rank.
#[derive(Debug, Clone)]
pub struct RankResults<T: Hash + Eq + Copy> {
    hand_table: BTreeMap<usize, Vec<HashSet<T>>>,
}

impl<T: Hash + Eq + Copy> RankResults<T> {
    /// Generates a new `RankResults<T>`.
    ///
    /// This does not do any other post-computation. This is typically called within the
    /// `generate_winner_list()` functions.
    pub fn new(hand_table: BTreeMap<usize, Vec<HashSet<T>>>) -> Self {
        Self {
            hand_table: hand_table,
        }
    }

    /// Gets the sepcified hand number if it exists.
    ///
    /// Similar to indexing an vector, this will either return a list of hashsets of keys which are
    /// sorted by the strength of the key's rank, or None if the index does not exist.
    pub fn hand_number(&self, n: usize) -> Option<&Vec<HashSet<T>>> {
        self.hand_table.get(&n)
    }
}

impl<'a, T: Hash + Eq + Copy> IntoIterator for &'a RankResults<T> {
    type Item = (usize, Vec<HashSet<T>>);
    type IntoIter = std::collections::btree_map::IntoIter<usize, Vec<HashSet<T>>>;

    fn into_iter(self) -> Self::IntoIter {
        self.hand_table.clone().into_iter()
    }
}

/// Generates a vector of type T which can be used to direct who is the winner.
///
/// This function assumes all `Vec<Rank>` types were generated by `high_evaluator::evaluate_hand()`.
/// Giving another `Vec<Rank>` from a different evaluator can lead to undefined behavior.
///
/// A `RankResults<T>` type is returned. This can then be used to view individual hand and can be
/// iterated across.
pub fn generate_winner_list<T, U>(ranks: &HashMap<T, U>) -> RankResults<T> where
    T: Eq + Hash + Copy,
    U: IntoRankStrengthIterator + Clone
{
    let mut iters = ranks.into_iter()
        .map(|(k, v)| {
            (k, v.clone().into_strength_iter())
        })
        .collect::<HashMap<_,_>>();

    let len = *match iters.iter()
        .map(|(_, iter)| {
            iter.len()
        })
        .collect::<Vec<_>>()
        .as_slice() {
        [head, tail @ ..] => tail.iter().all(|len| len == head).then(|| head),
        [] => None,
    }.unwrap_or(&0);

    let transpose: Vec<HashMap<T, u32>> = (0..len)
        .map(|_| {
            iters
                .iter_mut()
                .map(|(&k, v)| {
                    (k, v.next().unwrap().clone())
                })
                .filter(|(_, v)| v.is_some())
                .map(|(k, v)| (*k, v.unwrap()))
                .collect::<HashMap<T, u32>>()
        })
        .collect();

    let table: BTreeMap<usize, _> = transpose
        .iter()
        .enumerate()
        .map(|(i, ranks)| {
            let sorted_ranks_desc = ranks
                .iter()
                .sorted_by(|a, b| {
                    a.1.cmp(b.1)
                })
                .rev()
                .collect::<Vec<_>>();

            if sorted_ranks_desc.len() == 0 {
                return (i, vec![]);
            }

            let mut ranking_list = vec![HashSet::from([sorted_ranks_desc[0].0.clone()])];
            let _: () = sorted_ranks_desc.windows(2)
                .flat_map(<&[(&T, &u32); 2]>::try_from)
                .map(|&[(_, prev_rank), (curr_id, curr_rank)]| {
                    if prev_rank == curr_rank {
                        ranking_list.last_mut().unwrap().insert(curr_id.clone());
                    } else {
                        ranking_list.push(HashSet::from([curr_id.clone()]));
                    }
                }).collect();

            (i, ranking_list)
        })
        .collect();

    RankResults::new(table)
}

#[cfg(test)]
mod tests {
    use crate::poker::{evaluators::{high_evaluator::HighRank, omaha_hilo_evaluator::OmahaHiLoRank, low_a5_evaluator::LowA5Rank}, evaluator_result::RankStrengthIterator};

    use super::*;

    #[test]
    fn get_simple_winner_list() {
        let ranks = HashMap::from([
            (1, OmahaHiLoRank {
                hi_rank: HighRank(BasicRank { strength: 4321, hand_rank: 5, sub_rank: 12, description: Some("Some sick hand".to_string()) }),
                lo_rank: Some(LowA5Rank(BasicRank { strength: 121, hand_rank: 7, sub_rank: 1, description: Some("Some good low hand".to_string()) })),
            }),
            (2, OmahaHiLoRank {
                hi_rank: HighRank(BasicRank { strength: 2012, hand_rank: 4, sub_rank: 1232, description: Some("Another sick hand".to_string()) }),
                lo_rank: None,
            })
        ]);

        let rank_results = generate_winner_list(&ranks);

        let expected_rank_results = BTreeMap::from([
            (0, vec![HashSet::from([1]), HashSet::from([2])]),
            (1, vec![HashSet::from([1])]),
        ]);
        for (winner_col, expected_winner_col) in rank_results.into_iter().zip(expected_rank_results.into_iter()) {
            assert_eq!(winner_col, expected_winner_col);
        }
    }

    #[derive(Debug, Clone, PartialEq, Eq)]
    struct DoubleBoardRank {
        pub top_board_rank: HighRank,
        pub bottom_board_rank: HighRank,
    }

    impl IntoRankStrengthIterator for DoubleBoardRank {
        fn into_strength_iter(self) -> RankStrengthIterator {
            RankStrengthIterator::from(vec![(*self.top_board_rank).strength, (*self.bottom_board_rank).strength])
        }
    }

    #[test]
    fn get_winner_list_custom_rank_type() {
        let ranks = HashMap::from([
            (1, DoubleBoardRank {
                top_board_rank: HighRank(BasicRank { strength: 2034, hand_rank: 4, sub_rank: 8, description: Some("Decent high hand".to_string()) }),
                bottom_board_rank: HighRank(BasicRank { strength: 7922, hand_rank: 7, sub_rank: 24, description: Some("Nutted high hand".to_string()) }),
            }),
            (2, DoubleBoardRank{
                top_board_rank: HighRank(BasicRank { strength: 5000, hand_rank: 6, sub_rank: 54, description: Some("The nuts on the top board".to_string()) }),
                bottom_board_rank: HighRank(BasicRank { strength: 800, hand_rank: 1, sub_rank: 27, description: Some("No pair hand".to_string()) }),
            }),
        ]);

        let rank_results = generate_winner_list(&ranks);

        let expected_rank_results = BTreeMap::from([
            (0, vec![HashSet::from([2]), HashSet::from([1])]),
            (1, vec![HashSet::from([1]), HashSet::from([2])]),
        ]);

        for (winner_col, expected_winner_col) in rank_results.into_iter().zip(expected_rank_results.into_iter()) {
            assert_eq!(winner_col, expected_winner_col);
        }
    }

    #[test]
    fn winner_list_same_rank() {
        let ranks = HashMap::from([
            (1, HighRank(
                BasicRank {
                    strength: 4321,
                    hand_rank: 5,
                    sub_rank: 12,
                    description: Some("Sick hand".to_string()),
                }
            )),
            (2, HighRank(
                BasicRank {
                    strength: 4321,
                    hand_rank: 5,
                    sub_rank: 12,
                    description: Some("Sick hand".to_string()),
                }
            ))
        ]);

        let rank_results = generate_winner_list(&ranks);

        let expected_rank_results = BTreeMap::from([
            (0, vec![HashSet::from([1, 2])]),
        ]);
        for (winner_col, expected_winner_col) in rank_results.into_iter().zip(expected_rank_results.into_iter()) {
            assert_eq!(winner_col, expected_winner_col);
        }
    }

    #[test]
    fn generate_winners_from_empty_input() {
        let ranks: HashMap<i32, HighRank> = HashMap::new();

        let rank_results = generate_winner_list(&ranks);

        let expected_rank_results: RankResults<i32> = RankResults::new(
            BTreeMap::new()
        );

        for (winner_col, expected_winner_col) in rank_results.into_iter().zip(expected_rank_results.into_iter()) {
            assert_eq!(winner_col, expected_winner_col);
        }
    }
}
