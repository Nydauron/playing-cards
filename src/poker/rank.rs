use std::{cmp::Ordering, hash::Hash, collections::{HashSet, HashMap, BTreeMap}};

use itertools::Itertools;

use super::evaluator_result::IntoRankStrengthIterator;

/// A fundational struct to contain hand strength metadata.
///
/// The `BasicRank` struct is fairly trasparent allowing for easy access for evaluators to create
/// and modify values within the struct. The struct primarily stores information on hand strength,
/// even containing information on hand rank and sub rank if the user wants to utilize those
/// properites.
///
/// A provided description is also included to allow for the user to understand what the rank is in
/// English. Typically, the `description` field is going to be the the strength of the hand, but if
/// the evaluator fails for whatever reason, it will contain an error message instead.
///
/// Ranks can be compared with each other using the typical equality and inequality operations.
/// The evaluators that are provided in the `evaluator` module produce structs that rely on this
/// foundational struct.
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct BasicRank {
    /// The strength of the `Rank`.
    ///
    /// This field is what is used within the implematation of `Ord`
    /// and `Eq`.
    pub strength: u32,

    /// the hand rank of the associated rank.
    ///
    /// Two different ranks from two different evaluators might have the same `strength`, they may
    /// differ in `hand_rank`.
    pub hand_rank: u16,

    /// The sub rank of the associated rank.
    ///
    /// Typically `sub_rank` is used in tandem with `hand_rank`.
    pub sub_rank: u16,

    /// An optional description for the rank.
    ///
    /// All the provided evaluators in this library fill this field. Typically, value that is
    /// populated is a Enlgish version of the hand made (e.g. "Trip 5s", "Kings full of 9s"). If
    /// the evaluator fails to generate a valid description, the error string will be populated
    /// here.
    pub description: Option<String>,
}

impl Ord for BasicRank {
    fn cmp(&self, other: &Self) -> Ordering {
        self.strength.cmp(&other.strength)
    }
}

impl PartialOrd for BasicRank {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

/// Contains information on which key has the strongest rank (i.e the winning hand).
///
/// The struct does not contain any `Rank` types, but rather contains the keys associated with the
/// rank. The underlying implementation uses HashSets to store the keys so the generic type `T`
/// must fulfill the traits `Hash`, `Eq`, and `Copy`.
///
/// The vectors returned by the iterator or `hand_number(&self)` is a list of hashsets of keys. The
/// list is sorted by strength of the key's rank with index 0 being of the strongest rank.
#[derive(Debug, Clone)]
pub struct RankResults<T: Hash + Eq + Copy> {
    hand_table: BTreeMap<usize, Vec<HashSet<T>>>,
}

impl<T: Hash + Eq + Copy> RankResults<T> {
    /// Generates a new `RankResults<T>`.
    ///
    /// This does not do any other post-computation. This is typically called within the
    /// `generate_winner_list()` functions.
    pub fn new(hand_table: BTreeMap<usize, Vec<HashSet<T>>>) -> Self {
        Self {
            hand_table: hand_table,
        }
    }

    /// Gets the sepcified hand number if it exists.
    ///
    /// Similar to indexing an vector, this will either return a list of hashsets of keys which are
    /// sorted by the strength of the key's rank, or None if the index does not exist.
    pub fn hand_number(&self, n: usize) -> Option<&Vec<HashSet<T>>> {
        self.hand_table.get(&n)
    }
}

impl<'a, T: Hash + Eq + Copy> IntoIterator for &'a RankResults<T> {
    type Item = (usize, Vec<HashSet<T>>);
    type IntoIter = std::collections::btree_map::IntoIter<usize, Vec<HashSet<T>>>;

    fn into_iter(self) -> Self::IntoIter {
        self.hand_table.clone().into_iter()
    }
}

/// Generates a vector of type T which can be used to direct who is the winner.
///
/// This function assumes all `Vec<Rank>` types were generated by `high_evaluator::evaluate_hand()`.
/// Giving another `Vec<Rank>` from a different evaluator can lead to undefined behavior.
///
/// A `RankResults<T>` type is returned. This can then be used to view individual hand and can be
/// iterated across.
pub fn generate_winner_list<T: Eq + Hash + Copy>(ranks: &HashMap<T, Vec<Rank>>) -> RankResults<T> {
    assert!(!ranks.is_empty());
    let mut len = None;
    for (_, v) in ranks {
        if let Some(len) = len {
            assert!(v.len() == len);
        } else {
            len = Some(v.len());
        }
    }
    let len = len.unwrap_or(0);

    let mut iters: HashMap<T, _> = ranks
        .into_iter()
        .map(|(&k, v)|
            (k, v.into_iter())
        ).collect();
    let transpose: Vec<HashMap<T, Rank>> = (0..len)
        .map(|_| {
            iters
                .iter_mut()
                .map(|(&k, v)| {
                    (k, v.next().unwrap().clone())
                })
                .collect::<HashMap<T, Rank>>()
        })
        .collect();

    let table: BTreeMap<usize, _> = transpose
        .iter()
        .enumerate()
        .map(|(i, ranks)| {
            let sorted_ranks_desc = ranks
                .iter()
                .sorted_by(|a, b| {
                    a.1.cmp(b.1)
                })
                .rev()
                .collect::<Vec<_>>();

            if sorted_ranks_desc.len() == 0 {
                return (i, vec![]);
            }

            let mut ranking_list = vec![HashSet::from([sorted_ranks_desc[0].0.clone()])];
            let _: () = sorted_ranks_desc.windows(2)
                .flat_map(<&[(&T, &Rank); 2]>::try_from)
                .map(|&[(_, prev_rank), (curr_id, curr_rank)]| {
                    if prev_rank == curr_rank {
                        ranking_list.last_mut().unwrap().insert(curr_id.clone());
                    } else {
                        ranking_list.push(HashSet::from([curr_id.clone()]));
                    }
                }).collect();

            (i, ranking_list)
        })
        .collect();

    RankResults::new(table)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn get_simple_winner_list() {
        let ranks = HashMap::from([
            (1, vec![
                Rank {
                    strength: 4321,
                    hand_rank: 5,
                    sub_rank: 12,
                    description: Some("Some sick hand".to_string()),
                },
                Rank {
                    strength: 121,
                    hand_rank: 7,
                    sub_rank: 1,
                    description: Some("Pretty good low hand".to_string()),
                },
            ]),
            (2, vec![
                Rank {
                    strength: 2012,
                    hand_rank: 4,
                    sub_rank: 1232,
                    description: Some("Another sick hand".to_string()),
                },
                Rank {
                    strength: 0,
                    hand_rank: 0,
                    sub_rank: 0,
                    description: Some("No low hand".to_string()),
                },
            ])
        ]);

        let rank_results = generate_winner_list(&ranks);

        let expected_rank_results = BTreeMap::from([
            (0, vec![HashSet::from([1]), HashSet::from([2])]),
            (1, vec![HashSet::from([1]), HashSet::from([2])]),
        ]);
        for (winner_col, expected_winner_col) in rank_results.into_iter().zip(expected_rank_results.into_iter()) {
            assert_eq!(winner_col, expected_winner_col);
        }
    }

    #[test]
    fn winner_list_same_rank() {
        let ranks = HashMap::from([
            (1, vec![
                Rank {
                    strength: 4321,
                    hand_rank: 5,
                    sub_rank: 12,
                    description: Some("Sick hand".to_string()),
                },
            ]),
            (2, vec![
                Rank {
                    strength: 4321,
                    hand_rank: 5,
                    sub_rank: 12,
                    description: Some("Sick hand".to_string()),
                },
            ])
        ]);

        let rank_results = generate_winner_list(&ranks);

        let expected_rank_results = BTreeMap::from([
            (0, vec![HashSet::from([1, 2])]),
        ]);
        for (winner_col, expected_winner_col) in rank_results.into_iter().zip(expected_rank_results.into_iter()) {
            assert_eq!(winner_col, expected_winner_col);
        }
    }
}
